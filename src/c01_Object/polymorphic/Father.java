package c01_Object.polymorphic;

/**
 * @ClassName Father
 * @description:
 *
 * 父类无任何构造器：
 *      子类无构造器：自动生成子类无参构造器，并隐式super调用父类自动生成的无参构造器
 *      子类只有无参构造器：不论子类写不写super,均会调用父类无参构造器
 *      子类只有有参构造器：
 *              子类不调用super 默认去调用父类的自动生成的无参构造器初始化父类
 *              子类手动调用super() 父类的无参数构造器， 效果一致
 *              子类手动调用super(param) 父类的有参数构造器，编译失败，因为父类不会自动创建有参构造器(不知道参数是哪些)
 *
 *      子类有有参构造器和无参构造器：同上
 *
 * 父类有无参构造器：与父类无任何构造器一致
 *
 * 父类只有有参构造器：
 *      子类无构造器：报错，必须手动创建有参构造器，并super(param) 调用父类有参构造器
 *      子类只有无参构造器：无法进行super()调用，该构造器会报错
 *      子类只有有参构造器：必须显式调用super(param) 父类有参构造器
 *      子类有有参构造器和无参构造器：
 *              子类无参构造器通过this 调用子类的其他有参构造器，否则报错，因为无法初始化父类(此时父类没有无参构造器)
 *
 * 父类有有参构造器和无参构造器：
 *      子类无构造器：默认调用父类无参构造器
 *      子类只有无参构造器：可以不写super,编译器自动调用默认父类的无参构造器，也可以指定父类的有参构造器或无参构造器
 *      子类只有有参构造器：可以不写super,编译器自动调用默认父类的无参构造器，也可以指定父类的有参构造器或无参构造器
 *      子类有有参构造器和无参构造器：同上
 *
 *
 *  总结：
 *  系统默认只能创建和super调用无参构造器
 *  核心就是必须要完成父类的初始化
 *
 *  static方法继承：
 *          不同与子类覆盖成员方法，子类可以隐藏父类的static方法
 *          覆盖与隐藏的区别：
 *                  强转成父类对象后，调用static方法，因为只被隐藏而非覆盖，可以调用到父类原有的static方法
 *                  强转成父类对象后，调用成员方法，因为子类覆盖了父类方法，此时调用的成员方法，只能走子类对象调用
 *
 *  成员变量的绑定：是前期绑定(静态绑定)
 *          即：向上转型(强转为父类对象时)，对象的成员方法可以找到子类，而对象的成员变量还是父类的成员变量（子类对父类成员变量的隐藏）
 *

 *
 * @author: isquz
 * @time: 2020/9/10 20:25
 */
public class Father {

    public String name = "父类属性";

    public static void fatherStaticFunc(){
        System.out.println("父类public static 方法");
    }

    public void fatherFieldFunc(){
        System.out.println("父类成员方法");
    }

    public Father(){
        System.out.println("父类无参构造器");
    }

    public Father(String s){
        System.out.println("父类有参构造器： " + s);
    }
}
